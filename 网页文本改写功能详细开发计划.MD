# 网页文本改写功能详细开发计划

## 项目概述

本计划旨在为现有的网页翻译插件添加文本改写功能。该功能将允许用户对网页中选中的文本进行自定义改写，通过编辑提示词来指导大模型完成特定的文本改写任务。

## 功能需求分析

### 核心功能
1. 文本选择同步：与现有翻译功能共享文本选择机制
2. 提示词编辑：提供可编辑的文本框供用户输入改写指令
3. 文本改写：调用大模型API完成文本改写任务
4. 结果展示：显示改写结果并提供复制功能
5. 统计信息：显示改写前后的文本统计信息

### 非功能性需求
1. 与现有翻译功能界面风格保持一致
2. 复用现有文本选择和消息传递机制
3. 支持多种大模型API调用
4. 提供良好的用户体验和错误处理

## 技术架构设计

### 前端组件
1. **Sidebar界面更新**
   - 添加提示词编辑区域
   - 添加改写结果展示区域
   - 添加相关操作按钮
   - 保持与现有翻译界面的一致性

2. **Content Script**
   - 复用现有的文本选择监听机制
   - 保持与Sidebar的消息传递机制

3. **Background Script**
   - 添加改写功能的API调用逻辑
   - 复用现有的大模型配置管理

### 后端集成
1. **大模型API调用**
   - 复用现有的大模型配置和调用机制
   - 添加针对改写任务的API请求构建逻辑

## 详细开发任务

### 第一阶段：界面设计与实现

#### 任务1.1: 更新Sidebar界面
- [ ] 在sidebar.html中添加提示词编辑区域
- [ ] 在sidebar.html中添加改写结果展示区域
- [ ] 添加"开始改写"和"复制改写结果"按钮
- [ ] 添加统计信息展示区域
- [ ] 确保界面风格与现有翻译功能保持一致

#### 任务1.2: 更新Sidebar脚本
- [ ] 在sidebar.js中添加提示词编辑区域的相关逻辑
- [ ] 实现"开始改写"按钮的点击事件处理
- [ ] 实现"复制改写结果"按钮的点击事件处理
- [ ] 添加改写结果的展示逻辑
- [ ] 添加统计信息的更新逻辑

### 第二阶段：功能逻辑实现

#### 任务2.1: 更新Background脚本
- [ ] 在background.js中添加处理改写请求的消息监听器
- [ ] 实现调用大模型API进行文本改写的逻辑
- [ ] 复用现有的大模型配置管理功能
- [ ] 添加错误处理和结果返回逻辑

#### 任务2.2: 完善Content Script
- [ ] 确保文本选择同步功能正常工作
- [ ] 验证与Sidebar的消息传递机制

### 第三阶段：测试与优化

#### 任务3.1: 功能测试
- [ ] 测试文本选择同步功能
- [ ] 测试提示词编辑功能
- [ ] 测试不同大模型的改写功能
- [ ] 测试结果展示和复制功能
- [ ] 测试统计信息展示功能

#### 任务3.2: 用户体验优化
- [ ] 优化界面布局和交互
- [ ] 添加必要的提示和帮助信息
- [ ] 优化错误处理和用户反馈
- [ ] 进行性能优化

## 具体实现细节

### Sidebar界面更新

#### HTML结构
1. 添加提示词编辑区域：
   ```html
   <div class="section">
       <h2>改写提示词</h2>
       <div class="form-group">
           <textarea id="rewritePrompt" class="prompt-textarea" placeholder="请输入改写指令，例如：请将以下文本改写得更加正式和专业..."></textarea>
       </div>
   </div>
   ```

2. 添加改写结果展示区域：
   ```html
   <div class="section">
       <h2>改写结果</h2>
       <div class="result-container">
           <div id="rewriteResult">点击"开始改写"按钮来改写选中的文本</div>
       </div>
       <div style="margin-top: 15px;">
           <button id="copyRewriteBtn" class="btn-secondary">📋 复制改写结果</button>
       </div>
       <div class="stats">
           <div class="stats-item">改写时间: <span id="rewriteTime">-</span></div>
           <div class="stats-item">原字符数: <span id="originalCharCount">-</span></div>
           <div class="stats-item">改写后字符数: <span id="rewriteCharCount">-</span></div>
       </div>
   </div>
   ```

3. 添加"开始改写"按钮：
   ```html
   <button id="rewriteBtn" class="btn-primary">🔄 开始改写</button>
   ```

#### CSS样式
1. 添加提示词编辑区域样式：
   ```css
   .prompt-textarea {
       width: 100%;
       min-height: 100px;
       padding: 8px;
       border: 1px solid #ddd;
       border-radius: 4px;
       box-sizing: border-box;
       font-family: Arial, sans-serif;
       resize: vertical;
   }
   ```

### JavaScript逻辑实现

#### Sidebar脚本更新
1. 添加DOM元素引用：
   ```javascript
   const rewritePrompt = document.getElementById('rewritePrompt');
   const rewriteBtn = document.getElementById('rewriteBtn');
   const rewriteResult = document.getElementById('rewriteResult');
   const copyRewriteBtn = document.getElementById('copyRewriteBtn');
   const rewriteTime = document.getElementById('rewriteTime');
   const originalCharCount = document.getElementById('originalCharCount');
   const rewriteCharCount = document.getElementById('rewriteCharCount');
   ```

2. 添加事件监听器：
   ```javascript
   rewriteBtn.addEventListener('click', async function() {
       // 实现改写功能
   });
   
   copyRewriteBtn.addEventListener('click', function() {
       // 实现复制改写结果功能
   });
   ```

3. 实现改写功能：
   ```javascript
   async function performRewrite() {
       const prompt = rewritePrompt.value;
       const text = currentText; // 复用翻译功能中的currentText变量
       
       if (!text.trim()) {
           rewriteResult.textContent = '没有可改写的文本内容';
           return;
       }
       
       if (!prompt.trim()) {
           rewriteResult.textContent = '请输入改写提示词';
           return;
       }
       
       // 更新界面状态
       rewriteBtn.textContent = '🔄 改写中...';
       rewriteBtn.disabled = true;
       
       try {
           // 发送改写请求到background script
           const response = await chrome.runtime.sendMessage({
               action: "rewrite",
               text: text,
               prompt: prompt,
               model: modelSelect.value
           });
           
           // 处理响应
           if (response && response.success) {
               displayRewriteResult(response.result);
           } else {
               throw new Error(response?.error || '改写请求失败');
           }
       } catch (error) {
           console.error('Rewrite error:', error);
           rewriteResult.textContent = `改写失败: ${error.message}`;
       } finally {
           // 恢复界面状态
           rewriteBtn.textContent = '🔄 开始改写';
           rewriteBtn.disabled = false;
       }
   }
   ```

4. 实现结果显示：
   ```javascript
   function displayRewriteResult(result) {
       if (result.error) {
           rewriteResult.textContent = `改写失败: ${result.error}`;
           return;
       }
       
       // 显示改写结果
       rewriteResult.textContent = result.text || '无改写结果';
       
       // 更新统计信息
       rewriteTime.textContent = result.rewriteTime ? `${result.rewriteTime}秒` : '-';
       originalCharCount.textContent = result.originalCharCount || '-';
       rewriteCharCount.textContent = result.rewriteCharCount || '-';
   }
   ```

#### Background脚本更新

1. 添加消息监听器：
   ```javascript
   chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
       switch (request.action) {
           // ... existing cases ...
           case "rewrite":
               handleRewriteRequest(request, sender, sendResponse);
               return true; // 保持消息通道开放
       }
   });
   ```

2. 实现改写请求处理：
   ```javascript
   async function handleRewriteRequest(request, sender, sendResponse) {
       try {
           const { text, prompt, model } = request;
           
           // 构建改写提示词
           const fullPrompt = `${prompt}\n\n需要改写的文本：${text}`;
           
           // 调用大模型API
           const result = await callModelAPI(model, fullPrompt);
           
           // 返回结果
           sendResponse({
               success: true,
               result: {
                   text: result.text,
                   rewriteTime: result.time,
                   originalCharCount: text.length,
                   rewriteCharCount: result.text.length
               }
           });
       } catch (error) {
           console.error('Rewrite request failed:', error);
           sendResponse({
               success: false,
               error: error.message
           });
       }
   }
   ```

3. 实现大模型API调用：
   ```javascript
   async function callModelAPI(model, prompt) {
       // 复用现有的模型配置和API调用逻辑
       const config = await loadModelConfig(model);
       
       // 根据不同模型构建请求
       switch (model) {
           case 'kimi':
               return await callKimiAPI(config, prompt);
           case 'deepseek':
               return await callDeepSeekAPI(config, prompt);
           case 'qwen':
               return await callQwenAPI(config, prompt);
           case 'doubao':
               return await callDoubaoAPI(config, prompt);
           default:
               throw new Error(`不支持的模型: ${model}`);
       }
   }
   ```

## 测试计划

### 功能测试
1. 文本选择同步测试
   - 验证在不同网页上选择文本能否正确同步到插件
   - 验证选中文本变化时插件能否实时更新

2. 提示词编辑测试
   - 验证提示词编辑框能否正常输入和编辑
   - 验证默认提示词是否正确显示

3. 改写功能测试
   - 验证不同大模型的改写功能是否正常
   - 验证改写结果是否正确显示
   - 验证统计信息是否正确计算

4. 复制功能测试
   - 验证复制改写结果功能是否正常
   - 验证复制按钮的反馈是否正确

### 兼容性测试
1. 浏览器兼容性测试
   - 在不同版本的Chrome浏览器上测试功能
   - 验证扩展在不同操作系统上的表现

2. 网站兼容性测试
   - 在不同类型的网站上测试文本选择功能
   - 验证在特殊网站（如百度）上的表现

### 性能测试
1. 响应时间测试
   - 测试文本选择同步的响应时间
   - 测试改写功能的响应时间

2. 资源占用测试
   - 监控扩展的内存占用情况
   - 监控扩展的CPU使用情况

## 风险评估与应对措施

### 技术风险
1. **文本选择同步问题**
   - 风险：在某些特殊网站上可能无法正确获取选中文本
   - 应对：准备备选方案，如通过其他方式获取文本

2. **大模型API调用问题**
   - 风险：不同大模型的API接口可能存在差异
   - 应对：为每个模型实现独立的调用逻辑

3. **性能问题**
   - 风险：改写功能可能导致界面卡顿
   - 应对：优化代码逻辑，添加加载状态提示

### 用户体验风险
1. **界面复杂度增加**
   - 风险：新增功能可能导致界面过于复杂
   - 应对：保持界面简洁，提供清晰的操作指引

2. **功能理解困难**
   - 风险：用户可能不理解如何使用改写功能
   - 应对：提供默认提示词模板和使用示例

## 项目时间规划

### 第一阶段：界面设计与实现 (3天)
- 第1天：完成sidebar.html的界面更新
- 第2天：完成sidebar.js的逻辑实现
- 第3天：完成样式调整和初步测试

### 第二阶段：功能逻辑实现 (4天)
- 第1天：完成background.js的改写功能实现
- 第2天：完成content script的验证和调整
- 第3天：完成不同大模型的适配
- 第4天：完成错误处理和结果返回逻辑

### 第三阶段：测试与优化 (3天)
- 第1天：完成功能测试和bug修复
- 第2天：完成兼容性测试和性能优化
- 第3天：完成用户体验优化和文档编写

## 验收标准

1. 功能完整性
   - 文本选择同步功能正常
   - 提示词编辑功能正常
   - 改写功能支持所有大模型
   - 结果展示和复制功能正常
   - 统计信息展示正确

2. 用户体验
   - 界面布局合理，操作流畅
   - 错误提示清晰明确
   - 响应时间在可接受范围内

3. 代码质量
   - 代码结构清晰，易于维护
   - 遵循现有代码风格和规范
   - 有适当的注释和文档

4. 兼容性
   - 在主流浏览器上功能正常
   - 在常见网站上文本选择功能正常